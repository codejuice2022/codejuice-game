<html>

<head>
  <title>test..</title>
</head>

<body style="margin: 0">
  <img src="./GC.png" />
  <canvas id="canvas" style="width: calc(100vh * 16 / 10); height: 100vh; display: block;"></canvas>
</body>

</html>

<script>
  const colCheck = (shapeA, shapeB) => {
    // get the vectors to check against
    var vX = (shapeA.x + (shapeA.width / 2)) - (shapeB.x + (shapeB.width / 2)),
      vY = (shapeA.y + (shapeA.height / 2)) - (shapeB.y + (shapeB.height / 2)),
      // add the half widths and half heights of the objects
      hWidths = (shapeA.width / 2) + (shapeB.width / 2),
      hHeights = (shapeA.height / 2) + (shapeB.height / 2),
      colDir = null;

    // if the x and y vector are less than the half width or half height, they we must be inside the object, causing a collision
    if (Math.abs(vX) < hWidths && Math.abs(vY) < hHeights) {
      // figures out on which side we are colliding (top, bottom, left, or right)
      var oX = hWidths - Math.abs(vX),
        oY = hHeights - Math.abs(vY);
      if (oX >= oY) {
        if (vY < 0) {
          colDir = "b";
          shapeA.y -= oY;
        }
      } else {
        if (vX > 0) {
          colDir = "l";
          shapeA.x += oX;
        } else {
          colDir = "r";
          shapeA.x -= oX;
        }
      }
    }
    return colDir;
  }

  const playGame = (_map) => {

    const width = 1600;
    const height = 1000;
    const tileSize = 150;
    const platformHeight = 15;

    const platform = [];
    const items = [];

    _map.forEach((line, lineIndex) => {

      line.forEach((tile, tileIndex) => {
        switch (tile) {
          case 1:
            const prevTile = line[tileIndex - 1];

            if (prevTile === 1) {
              platform[platform.length - 1] = {
                ...platform[platform.length - 1],
                width: platform[platform.length - 1].width + tileSize,
              }
            } else {
              platform.push({//box for the ground
                x: tileSize * tileIndex,
                y: (lineIndex + 1) * (height / _map.length) - platformHeight,
                width: tileSize,
                height: platformHeight,
                color: 'orange',
                type: 'platform'
              });
            }
            break;

          default:
            break;
        }
      })
    });

    const canvas = document.getElementById("canvas"),
      boxSpeed = 2,
      ctx = canvas.getContext("2d"),
      player = {
        x: 30,
        y: 200,
        width: 80,
        height: 150,
        jumSize: 15,
        velX: 0,
        velY: 0,
        jumping: false,
        grounded: false,
        color: '#E6AC27'
      },
      keys = [],
      friction = 0.8,
      gravity = 0.4,
      boxes = [],
      powerup = [];

    // dimensions
    boxes.push({//box for the ground
      x: 0,
      y: height - 10,
      width: width,
      height: 50,
      color: 'orange',
      type: 'ground'
    });

    boxes.push({
      x: 290,
      y: 200,
      width: 260,
      height: 10,
      color: 'blue'
    });

    canvas.width = width;
    canvas.height = height;

    function update() {
      // check keys
      if (keys[38] || keys[32] || keys[87]) {
        // up arrow or space
        if (!player.jumping && player.grounded) {
          player.jumping = true;
          player.grounded = false;
          player.velY = -player.jumSize
        }
      }

      ctx.clearRect(0, 0, width, height);
      ctx.beginPath();

      player.grounded = false;

      for (var i = 0; i < platform.length; i++) {//print platform
        ctx.fillStyle = platform[i].color;

        const boxX = platform[i].x -= boxSpeed
        ctx.rect(boxX, platform[i].y, platform[i].width, platform[i].height);

        if (player.velY > 0) {
          var dir = colCheck(player, platform[i]);

          if (dir === "b") {
            player.grounded = true;
            player.jumping = false;
          }
        }
      }

      if (player.grounded) {
        player.velY = 0;
      } else {
        player.velY += gravity;
      }

      player.x += player.velX;
      player.y += player.velY;

      ctx.fill();//Draw charater stuff
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.width, player.height);

      //draw powerup stuff 
      for (var j = 0; j < powerup.length; j++) {
        ctx.save();
        ctx.fillStyle = powerup[j].color;
        ctx.fillRect(powerup[j].x, powerup[j].y, powerup[j].width, powerup[j].height);
        ctx.restore();
      }
      //powerup stuff

      requestAnimationFrame(update);
    }

    update();

  }

  const SET_CANVAS_OPTION = 'SET_CANVAS_OPTION'
  const GET_GAME_LOG = 'GET_GAME_LOG'

  const sendLog = (_message) => {
    if (window.ReactNativeWebView) {
      window.ReactNativeWebView.postMessage(
        JSON.stringify({
          type: GET_GAME_LOG,
          message: _message
        })
      );
    } else {
      console.log(_message)
    }
  }

  const rnListener = (event) => {
    const parseData = JSON.parse(event.data);

    switch (parseData.type) {
      case SET_CANVAS_OPTION:
        playGame(parseData.data.map);
        break;

      default:
        break;
    }
  }

  document.addEventListener('message', rnListener);
  /** ios */
  window.addEventListener('message', rnListener);
</script>